    def update_pose(self):
        state = self.state

        trans = self.robot_node.getField("translation").getSFVec3f()
        rot = self.robot_node.getField("rotation").getSFRotation()

        state.x = trans[0]
        state.y = trans[2]
        state.theta = rot[3]

        tx, ty = self.get_current_path_target_point()
        dx = tx - state.x
        dy = ty - state.y

        dist = math.hypot(dx, dy)
        state.distance_to_goal = dist

        target_theta = math.atan2(dy, dx)
        heading_err = target_theta - state.theta
        state.heading_error = (heading_err + math.pi) % (2.0 * math.pi) - math.pi

        gx, gy = GOAL_POSITION
        dist_final_goal = math.hypot(state.x - gx, state.y - gy)
        if (
            state.current_high_level_target != "CHARGE"
            and dist_final_goal < GOAL_REACHED_DIST
        ):
            if not state.mission_done:
                print(">>> [TASK] Final goal reached, mission done.")
            state.mission_done = True

        if (
            state.path
            and dist < WAYPOINT_REACHED_DIST
            and state.path_index < len(state.path) - 1
        ):
            state.path_index += 1

        if state.current_high_level_target == "CHARGE":
            target_x, target_y = CHARGING_STATION
        else:
            target_x, target_y = GOAL_POSITION

        dist_to_high_target = math.hypot(state.x - target_x, state.y - target_y)

        last = state.last_target_dist
        if last is None:
            state.last_target_dist = dist_to_high_target
        else:
            if abs(dist_to_high_target - last) < 0.005:
                state.no_progress_ticks += 1
            else:
                state.no_progress_ticks = 0
            state.last_target_dist = dist_to_high_target

        return state.current_high_level_target
