# intelligent_robot_controller.py
# 智能机器人项目控制器骨架（版本：稳定避障 + 减抖动 + 改进脱困）

from controller import Supervisor
import math

TIME_STEP = 64  # 仿真时间步长（必须与 world basicTimeStep 一致）

# !!! 把这里改成你在 world 里看到的小车初始 translation 的 (x, y) !!!
START_X = -3.0
START_Y = -3.0

# !!! 把这里改成 goal 在 world 里的 (x, y) !!!
GOAL_POSITION = (1.0, 1.0)

CHARGING_STATION = (3.0, -3.0)

# 认为在 15cm 以内就算到达目标
GOAL_REACHED_DIST = 0.15


# =====================================================================
# 一、机器人状态类（RobotState）
# =====================================================================

class RobotState:
    def __init__(self):
        # 电池系统
        self.battery_level = 100.0
        
        # 障碍物相关
        self.min_obstacle_distance = 1.0
        self.obstacle_danger = 0.0

        # 左右障碍强度
        self.left_obstacle = 0.0
        self.right_obstacle = 0.0
        
        # 机器人位姿（这里用世界坐标，平面是 x-y，z 为高度忽略）
        self.x = START_X     # 世界坐标 x
        self.y = START_Y     # 世界坐标 y
        self.theta = 0.0     # 朝向（弧度），0 约为 +x 方向
        
        
        self.going_to_charging = False
        
        # 目标相关
        self.distance_to_goal = 0.0
        self.heading_error = 0.0   # 机器人朝向 与 “目标方向” 的差值（-pi~pi）
        self.goal_visible = 1.0
        
        # 路径偏差程度
        self.path_deviation = 0.0
        
        # 卡住指标（后面如果要检测卡死可以用）
        self.stuck_indicator = 0.0


# =====================================================================
# 二、行为基类（Behavior）
# =====================================================================

class Behavior:
    """所有行为的父类"""
    def __init__(self, name):
        self.name = name
    
    def compute_activation(self, state: RobotState):
        return 0.0
    
    def execute(self, state: RobotState):
        return 0.0, 0.0


# =====================================================================
# 三、基础行为（避障、导航、紧急脱困）
# =====================================================================

class AvoidObstacleBehavior(Behavior):
    def __init__(self):
        super().__init__("AvoidObstacle")
    
    def compute_activation(self, state: RobotState):
        # 已经到达目标，完全关闭避障行为
        if state.distance_to_goal < GOAL_REACHED_DIST:
            return 0.0
        # 危险越高越优先
        return state.obstacle_danger

    def execute(self, state: RobotState):
        d = state.obstacle_danger

        # 非常近 —— 强制直线快速后退（比以前更容易触发）
        if d > 0.7:
            return -5.0, -5.0

        # 中等危险：一边后退一边转向
        left = state.left_obstacle
        right = state.right_obstacle

        # 左边障碍明显多 → 向右后退
        if left > right + 0.05:
            return -2.0, -4.0

        # 右边障碍明显多 → 向左后退
        if right > left + 0.05:
            return -4.0, -2.0

        # 两边差不多 → 原地旋转，找个新的方向
        return -2.5, 2.5


class NavigateBehavior(Behavior):
    def __init__(self):
        super().__init__("NavigateToGoal")
    
    def compute_activation(self, state: RobotState):
        if state.distance_to_goal < GOAL_REACHED_DIST:
            return 0.0
        base = 1.0 - state.obstacle_danger
        if state.distance_to_goal < 0.3:
            base *= 0.5
        return max(0.0, min(1.0, base))

    def execute(self, state: RobotState):
        # 1) 已经在目标附近 → 停
        if state.distance_to_goal < GOAL_REACHED_DIST:
            print("[NAV] Goal reached, stopping.")
            return 0.0, 0.0

        # 2) 基础前进速度
        base_speed = 4.0

        # 3) 计算转向量 w，并强行“不要太大”
        k_turn = 2.0              # 比原来 5.0 小很多，不那么暴躁
        w = k_turn * state.heading_error

        # 关键：限制 w 的大小，确保 |w| < base_speed
        w_max = 3.0               # 3 < base_speed=4，保证前进分量为正
        if w > w_max:
            w = w_max
        elif w < -w_max:
            w = -w_max

        # 4) 计算左右轮速度（一定都为正数）
        left = base_speed - w
        right = base_speed + w

        # 5) 限制最大轮速
        max_speed = 6.28
        left = max(-max_speed, min(max_speed, left))
        right = max(-max_speed, min(max_speed, right))

        # 6) 到目标很近时整体减速
        if state.distance_to_goal < 0.3:
            left *= 0.5
            right *= 0.5

        print(f"[CMD] NavigateToGoal -> vL={left:.2f}, vR={right:.2f}")
        return left, right


class EmergencyStopBehavior(Behavior):
    """
    改进版脱困行为：
    - phase 1: 大力后退
    - phase 2: 原地转向（方向伪随机）
    - phase 3: 低速前冲
    - phase 4: 挂起一帧，根据新危险度决定是否再次脱困或退出
    """
    def __init__(self):
        super().__init__("EmergencyStop")

        self.phase = 0          # 0 未启动  1 后退  2 转向  3 前冲  4 挂起
        self.step  = 0
        self.turn_dir = 1       # +1 左转   -1 右转

    def compute_activation(self, state: RobotState):
        # 已经到达目标，就不要再紧急脱困
        if state.distance_to_goal < GOAL_REACHED_DIST:
            self.phase = 0
            self.step = 0
            return 0.0

        # 正在执行脱困序列 → 必须保持激活
        if self.phase > 0:
            return 1.0

        # 危险非常大才启动紧急脱困（阈值从 0.95 降到 0.7）
        if state.obstacle_danger > 0.7:
            self.phase = 1
            self.step = 0
            # 用位置的奇偶性做一个简单伪随机，决定左转还是右转
            self.turn_dir = 1 if (state.x + state.y) % 2.0 < 1.0 else -1
            print("[EST] START back-off")
            return 1.0

        return 0.0

    def execute(self, state: RobotState):
        # 尚未启动（一般不会发生）
        if self.phase == 0:
            return 0.0, 0.0

        # 1) 后退 60 步（先退远点）
        if self.phase == 1:
            if self.step < 60:
                self.step += 1
                return -6.0, -6.0
            else:
                self.phase = 2
                self.step = 0
                print("[EST] START turn")

        # 2) 原地转向 50 步（方向随机）
        if self.phase == 2:
            if self.step < 50:
                self.step += 1
                return -4.0 * self.turn_dir, 4.0 * self.turn_dir
            else:
                self.phase = 3
                self.step = 0
                print("[EST] START escape")

        # 3) 低速前冲 30 步（试图离开墙面）
        if self.phase == 3:
            if self.step < 30:
                self.step += 1
                return 3.0, 3.0
            else:
                self.phase = 4          # 进入挂起，让传感器更新
                self.step = 0
                print("[EST] WAIT sensor")

        # 4) 挂起：只有 danger 仍然爆表才再开一轮，否则退出
        if self.phase == 4:
            if state.obstacle_danger > 0.7:
                self.phase = 1          # 再来一轮
                self.step  = 0
                print("[EST] RETRY")
            else:
                self.phase = 0          # 危险解除，正常退出
        return 0.0, 0.0


# =====================================================================
# 模糊决策（目前还没启用，只是占位）
# =====================================================================

class FuzzyDecision:
    def __init__(self):
        pass

    def danger_low(self, x: float) -> float:
        if x <= 0.3:
            return 1.0
        elif x >= 0.5:
            return 0.0
        else:
            return (0.5 - x) / (0.5 - 0.3)

    def danger_medium(self, x: float) -> float:
        if x <= 0.2 or x >= 0.8:
            return 0.0
        elif x <= 0.5:
            return (x - 0.2) / (0.5 - 0.2)
        else:
            return (0.8 - x) / (0.8 - 0.5)

    def danger_high(self, x: float) -> float:
        if x <= 0.6:
            return 0.0
        elif x >= 0.8:
            return 1.0
        else:
            return (x - 0.6) / (0.8 - 0.6)

    def get_activations(self, state: RobotState):
        d = state.obstacle_danger

        mu_low = self.danger_low(d)
        mu_med = self.danger_medium(d)
        mu_high = self.danger_high(d)

        navigate = 0.0
        avoid = 0.0
        stop = 0.0

        # Low
        navigate = max(navigate, mu_low * 1.0)
        avoid    = max(avoid,    mu_low * 0.1)
        stop     = max(stop,     mu_low * 0.0)

        # Medium
        navigate = max(navigate, mu_med * 0.5)
        avoid    = max(avoid,    mu_med * 1.0)
        stop     = max(stop,     mu_med * 0.2)

        # High
        navigate = max(navigate, mu_high * 0.1)
        avoid    = max(avoid,    mu_high * 0.5)
        stop     = max(stop,     mu_high * 1.0)

        navigate = min(1.0, navigate)
        avoid    = min(1.0, avoid)
        stop     = min(1.0, stop)

        return {
            "NavigateToGoal": navigate,
            "AvoidObstacle": avoid,
            "EmergencyStop": stop
        }


# =====================================================================
# 四、行为树 (Behavior Tree) —— 加入“迟滞”和“最小停留时间”
# =====================================================================

class BehaviorTree:
    def __init__(self, behaviors, fuzzy_decision=None):
        self.behaviors = behaviors
        self.fuzzy = fuzzy_decision

        self.current_behavior = None
        self.last_switch_tick = 0

    def decide(self, state: RobotState, tick: int):
        # 目前先不用模糊逻辑，直接用各个行为的 compute_activation，
        # 但加入“迟滞 + 最小停留时间”防止频繁抖动。
        if self.fuzzy is None:
            activations = {}
            for b in self.behaviors:
                activations[b] = b.compute_activation(state)

            # 初次选择
            if self.current_behavior is None:
                best_behavior = max(activations, key=activations.get)
                self.current_behavior = best_behavior
                self.last_switch_tick = tick
                print(f"[BT] Init -> {best_behavior.name} (a={activations[best_behavior]:.2f}, tick={tick})")
                return self.current_behavior

            # 当前行为和最佳行为
            best_behavior = max(activations, key=activations.get)
            a_best = activations[best_behavior]
            a_curr = activations[self.current_behavior]

            # ======= 抖动抑制参数 =======
            MIN_DWELL = 15   # 一个行为至少持续 15 个 tick
            HYST = 0.15      # 新行为激活度至少比当前高 0.15 才切换

            chosen = self.current_behavior

            # 如果当前行为还没“待够久”，强制继续当前行为
            if tick - self.last_switch_tick < MIN_DWELL:
                chosen = self.current_behavior
            else:
                # 已经待够久了，且新行为明显更“值得” → 切换
                if a_best > a_curr + HYST:
                    chosen = best_behavior

            if chosen is not self.current_behavior:
                print(f"[BT] Switch {self.current_behavior.name} -> {chosen.name} "
                      f"(a_curr={a_curr:.2f}, a_best={a_best:.2f}, tick={tick})")
                self.current_behavior = chosen
                self.last_switch_tick = tick

            return self.current_behavior

        # 下面是留给模糊逻辑的分支（现在不用）
        activations = self.fuzzy.get_activations(state)
        best_name = max(activations, key=activations.get)
        best_activation = activations[best_name]

        best_behavior = None
        for b in self.behaviors:
            if b.name == best_name:
                best_behavior = b
                break

        if best_behavior is None:
            return None

        if self.current_behavior is None or best_behavior is not self.current_behavior:
            self.current_behavior = best_behavior
            self.last_switch_tick = tick
            print(f"[BT-FUZZY] Switch to {best_behavior.name} (a={best_activation:.2f}, tick={tick})")

        return self.current_behavior


# =====================================================================
# 五、主控制器：Webots 对接部分
# =====================================================================

class IntelligentRobotController(Supervisor):
    def __init__(self):
        super().__init__()
        
        # 保存机器人自身节点，用来读世界坐标
        self.robot_node = self.getSelf()

        # ---------------- 电机初始化 ----------------
        self.left_motor = self.getMotor("left wheel motor")
        self.right_motor = self.getMotor("right wheel motor")

        self.left_motor.setPosition(float('inf'))
        self.right_motor.setPosition(float('inf'))
        
        self.left_motor.setVelocity(0.0)
        self.right_motor.setVelocity(0.0)
        
        # ---------------- 距离传感器 ----------------
        self.distance_sensors = []
        sensor_names = ["ps0", "ps1", "ps2", "ps3", "ps4", "ps5", "ps6", "ps7"]
        for name in sensor_names:
            sensor = self.getDevice(name)
            if sensor is not None:
                sensor.enable(TIME_STEP)
                self.distance_sensors.append(sensor)
        
        # 机器人状态
        self.state = RobotState()
        
        # 行为树：优先级从高到低（EmergencyStop 一旦触发，会占据控制）
        self.behaviors = [
            EmergencyStopBehavior(),
            AvoidObstacleBehavior(),
            NavigateBehavior()
        ]
        self.fuzzy_decision = None

        self.bt = BehaviorTree(self.behaviors, self.fuzzy_decision)

        # tick 计数
        self.tick = 0
    def update_battery_and_target(self, moving: bool):
        """
        简单电量模型：
        - 机器人动的时候掉电快一点
        - 不动的时候掉电慢一点
        - 低电量时，把目标切换为充电站
        - 到达充电站后，缓慢充电，充满再回到主目标
        """
        # 1) 电量消耗
        if moving:
            self.state.battery_level -= 0.03    # 运动时每步掉 0.03
        else:
            self.state.battery_level -= 0.005   # 静止也有小损耗

        # 限制在 [0, 100]
        if self.state.battery_level < 0.0:
            self.state.battery_level = 0.0
        if self.state.battery_level > 100.0:
            self.state.battery_level = 100.0

        # 2) 低电量 → 切换到去充电站
        if (not self.state.going_to_charging) and self.state.battery_level < 30.0:
            self.state.going_to_charging = True
            print(">>> [BAT] Low battery, switch target to CHARGING STATION")

        # 3) 在充电站附近时，开始充电
        if self.state.going_to_charging and self.state.distance_to_goal < GOAL_REACHED_DIST:
            # 简单充电模型：每步加 0.5
            self.state.battery_level += 0.5
            if self.state.battery_level >= 99.0:
                self.state.battery_level = 100.0
                self.state.going_to_charging = False
                print(">>> [BAT] Fully charged, switch target back to GOAL")
    

    def update_odometry(self):
        # 1. 从世界里拿真实位置
        trans = self.robot_node.getField("translation").getSFVec3f()
        self.state.x = trans[0]   # 平面 x
        self.state.y = trans[1]   # 平面 y
    
        # 2. 真实朝向（假设只绕 z 轴转）
        rot = self.robot_node.getField("rotation").getSFRotation()
        axis_x, axis_y, axis_z, angle = rot
        self.state.theta = angle
    
        # 3. 计算与“当前目标”的距离和方向
        if self.state.going_to_charging:
            goal_x, goal_y = CHARGING_STATION
            target_name = "CHARGING"
        else:
            goal_x, goal_y = GOAL_POSITION
            target_name = "GOAL"
    
        dx = goal_x - self.state.x
        dy = goal_y - self.state.y
    
        distance = math.sqrt(dx * dx + dy * dy)
        self.state.distance_to_goal = distance
    
        target_theta = math.atan2(dy, dx)
        heading_err = target_theta - self.state.theta
        heading_err = (heading_err + math.pi) % (2 * math.pi) - math.pi
        self.state.heading_error = heading_err
    
        print(
            f"Pose(gt): x={self.state.x:.2f}, y={self.state.y:.2f}, "
            f"theta={self.state.theta:.2f}, dist={distance:.2f}, "
            f"target={target_name}, battery={self.state.battery_level:.1f}, "
            f"heading_err={heading_err:.2f}"
        )
        
    # =================================================================
    # 更新状态（重要）
    # =================================================================
    
    def update_state_from_sensors(self):
        if not self.distance_sensors:
            print("No distance sensors found!")
            return

        values = [s.getValue() for s in self.distance_sensors]
        max_val = max(values)

        print("Sensor values:", [int(v) for v in values], " max:", int(max_val))

        baseline = 60.0
        max_range = 80.0

        danger_raw = (max_val - baseline) / max_range
        danger = max(0.0, min(1.0, danger_raw))

        self.state.obstacle_danger = danger
        self.state.min_obstacle_distance = 1.0 - danger

        # 左右障碍强度估计
        if len(values) == 8:
            left_sum = values[0] + values[1] + values[2] + values[3]
            right_sum = values[4] + values[5] + values[6] + values[7]
        else:
            mid = len(values) // 2
            left_sum = sum(values[:mid])
            right_sum = sum(values[mid:])

        norm_factor = 400.0
        self.state.left_obstacle = min(1.0, left_sum / norm_factor)
        self.state.right_obstacle = min(1.0, right_sum / norm_factor)

        print(
            "Obstacle danger:", round(danger, 3),
            " | left:", round(self.state.left_obstacle, 3),
            " right:", round(self.state.right_obstacle, 3)
        )

    # =================================================================
    # 主程序循环
    # =================================================================
    def run_controller(self):
        # 上一次的控制命令，用于判断“是不是在动”
        last_left = 0.0
        last_right = 0.0

        while self.step(TIME_STEP) != -1:
            self.tick += 1

            # 0. 里程计：更新位姿 & 与目标的关系
            self.update_odometry()

            # 1. 传感器更新
            self.update_state_from_sensors()
            
            # 2. 行为树决策
            behavior = self.bt.decide(self.state, self.tick)
            
            # 3. 执行行为
            if behavior is None:
                left_speed, right_speed = 0.0, 0.0
            else:
                left_speed, right_speed = behavior.execute(self.state)
            
            # 4. 电量 + 任务切换（基于当前是否在动）
            moving = (abs(left_speed) > 0.1 or abs(right_speed) > 0.1)
            self.update_battery_and_target(moving)

            # 5. 设置轮速
            self.left_motor.setVelocity(left_speed)
            self.right_motor.setVelocity(right_speed)

            # 记录一下（目前没用，可以以后做“卡住检测”）
            last_left = left_speed
            last_right = right_speed

# =====================================================================
# 六、入口
# =====================================================================

if __name__ == "__main__":
    controller = IntelligentRobotController()
    controller.run_controller()
-----------------------------------------------------------1111111111111111111111------------------------------------------------------------

# intelligent_robot_controller.py
# 精简稳定版：直观导航 + 简单避障 + 电量管理 + 自动去充电站
# 去掉行为树 / 模糊系统，方便你调试和看懂

from controller import Supervisor
import math

TIME_STEP = 64  # 要和 world 里的 basicTimeStep 一致

# ======= 根据你给的截图设置 =======
# Robot:  position -3 -3 0.00017
# Goal:   position  1  1 2.69
# Charge: position  3 -3 0.3
START_X = -3.0
START_Y = -3.0

GOAL_POSITION = (1.0, 1.0)
CHARGING_STATION = (3.0, -3.0)

GOAL_REACHED_DIST = 0.15   # 认为到目标 15cm 内就算到达


class RobotState:
    def __init__(self):
        self.x = START_X
        self.y = START_Y
        self.theta = 0.0

        self.battery_level = 100.0

        self.going_to_charging = False
        self.distance_to_goal = 0.0
        self.heading_error = 0.0

        self.obstacle_danger = 0.0
        self.left_obstacle = 0.0
        self.right_obstacle = 0.0

        self.mission_done = False


class IntelligentRobotController(Supervisor):
    def __init__(self):
        super().__init__()

        self.robot_node = self.getSelf()

        # 电机
        self.left_motor = self.getDevice("left wheel motor")
        self.right_motor = self.getDevice("right wheel motor")

        self.left_motor.setPosition(float('inf'))
        self.right_motor.setPosition(float('inf'))

        self.left_motor.setVelocity(0.0)
        self.right_motor.setVelocity(0.0)

        # 距离传感器
        sensor_names = ["ps0", "ps1", "ps2", "ps3", "ps4", "ps5", "ps6", "ps7"]
        self.distance_sensors = []
        for name in sensor_names:
            s = self.getDevice(name)
            if s is not None:
                s.enable(TIME_STEP)
                self.distance_sensors.append(s)

        self.state = RobotState()
        self.tick = 0

    # ========== 姿态更新 ==========
    def update_pose(self):
        trans = self.robot_node.getField("translation").getSFVec3f()
        rot = self.robot_node.getField("rotation").getSFRotation()

        # 在你这个 world 里平面是 x-y，z 基本是高度
        self.state.x = trans[0]
        self.state.y = trans[1]

        axis_x, axis_y, axis_z, angle = rot
        # 轴基本是 (0,0,1)，直接把 angle 当朝向
        self.state.theta = angle

        # 选择当前的目标点
        if self.state.going_to_charging:
            gx, gy = CHARGING_STATION
            target_name = "CHARGE"
        else:
            gx, gy = GOAL_POSITION
            target_name = "GOAL"

        dx = gx - self.state.x
        dy = gy - self.state.y
        dist = math.hypot(dx, dy)
        self.state.distance_to_goal = dist

        target_theta = math.atan2(dy, dx)
        heading_err = target_theta - self.state.theta
        heading_err = (heading_err + math.pi) % (2.0 * math.pi) - math.pi
        self.state.heading_error = heading_err

        # 最终目标达成
        if (not self.state.going_to_charging) and dist < GOAL_REACHED_DIST:
            if not self.state.mission_done:
                print(">>> [TASK] Final goal reached, mission done.")
            self.state.mission_done = True

        return target_name

    # ========== 传感器 ==========
    def update_sensors(self):
        if not self.distance_sensors:
            return

        values = [s.getValue() for s in self.distance_sensors]
        max_val = max(values)

        # 这里的数值大概在 60~80 左右，越大越近
        baseline = 60.0
        max_range = 80.0
        danger_raw = (max_val - baseline) / max_range
        danger = max(0.0, min(1.0, danger_raw))
        self.state.obstacle_danger = danger

        # 左/右 4 个传感器求和
        if len(values) == 8:
            left_sum = sum(values[0:4])
            right_sum = sum(values[4:8])
        else:
            mid = len(values) // 2
            left_sum = sum(values[:mid])
            right_sum = sum(values[mid:])

        norm = 400.0
        self.state.left_obstacle = min(1.0, left_sum / norm)
        self.state.right_obstacle = min(1.0, right_sum / norm)

    # ========== 电量 & 目标切换 ==========
    def update_battery_and_target(self, moving: bool):
        if self.state.mission_done:
            return

        # 非常简单的电量模型
        if moving:
            self.state.battery_level -= 0.03
        else:
            self.state.battery_level -= 0.005

        if self.state.battery_level < 0.0:
            self.state.battery_level = 0.0
        if self.state.battery_level > 100.0:
            self.state.battery_level = 100.0

        # 低电 -> 切换去充电站
        if (not self.state.going_to_charging) and self.state.battery_level < 30.0:
            self.state.going_to_charging = True
            print(">>> [BAT] Low battery, go to CHARGING_STATION")

        # 在充电站附近就缓慢充电
        if self.state.going_to_charging and self.state.distance_to_goal < GOAL_REACHED_DIST:
            self.state.battery_level += 0.5
            if self.state.battery_level >= 100.0:
                self.state.battery_level = 100.0
                self.state.going_to_charging = False
                print(">>> [BAT] Fully charged, switch back to GOAL")

    # ========== 计算速度命令 ==========
    def compute_command(self):
        if self.state.mission_done or self.state.battery_level <= 0.0:
            return 0.0, 0.0

        d = self.state.distance_to_goal
        e = self.state.heading_error
        danger = self.state.obstacle_danger
        left_o = self.state.left_obstacle
        right_o = self.state.right_obstacle

        # 基本思路：
        # 1. 危险非常大：先强制后退 + 朝远离障碍的方向转
        # 2. 危险中等：减速 + 侧向绕开障碍
        # 3. 危险很小：按照朝向误差往目标开

        max_speed = 6.28

        # 1) 高危险：强制后退
        if danger > 0.7:
            turn_bias = 2.0 if left_o > right_o else -2.0
            v = -3.0
            w = turn_bias
        # 2) 中等危险：稍微减速并根据左右障碍差偏转
        elif danger > 0.3:
            v = 2.0
            w = 3.0 * (right_o - left_o)    # 左边更近则 w>0 → 往右转
        else:
            # 3) 正常导航：P 控制
            # 距离越远，线速度越大，最多 4.0
            v = 4.0 * min(d, 1.0)
            # 朝向误差越大，转得越狠
            w = 3.0 * e

        # 把 (v, w) 转成左右轮速度
        v_left = v - w
        v_right = v + w

        # 限制在电机允许的范围内
        v_left = max(-max_speed, min(max_speed, v_left))
        v_right = max(-max_speed, min(max_speed, v_right))

        return v_left, v_right

    # ========== 主循环 ==========
    def run_controller(self):
        last_log_tick = -999

        while self.step(TIME_STEP) != -1:
            self.tick += 1

            if self.state.battery_level <= 0.0:
                print(">>> [BAT] Battery empty, stop.")
                self.left_motor.setVelocity(0.0)
                self.right_motor.setVelocity(0.0)
                continue

            if self.state.mission_done:
                self.left_motor.setVelocity(0.0)
                self.right_motor.setVelocity(0.0)
                continue

            target_name = self.update_pose()
            self.update_sensors()

            v_left, v_right = self.compute_command()

            moving = (abs(v_left) > 0.05 or abs(v_right) > 0.05)
            self.update_battery_and_target(moving)

            self.left_motor.setVelocity(v_left)
            self.right_motor.setVelocity(v_right)

            # 每 20 个 tick 打一行日志，避免刷屏
            if self.tick - last_log_tick >= 20:
                last_log_tick = self.tick
                print(
                    f"[t={self.tick}] pos=({self.state.x:.2f},{self.state.y:.2f}) "
                    f"theta={self.state.theta:.2f} "
                    f"target={target_name} dist={self.state.distance_to_goal:.2f} "
                    f"batt={self.state.battery_level:.1f} "
                    f"danger={self.state.obstacle_danger:.2f} "
                    f"Lobs={self.state.left_obstacle:.2f} "
                    f"Robs={self.state.right_obstacle:.2f} "
                    f"cmd=({v_left:.2f},{v_right:.2f})"
                )


if __name__ == "__main__":
    controller = IntelligentRobotController()
    controller.run_controller()
-----------------------22222222222222222222模糊行为选择 + 抖动抑制骨架code--------------------------------------

# intelligent_robot_controller.py
# 升级版：在原基础上加入
# 1) 模糊行为激活 (GOAL / AVOID / CHARGE)
# 2) 行为选择 + 抖动抑制 (hysteresis + cooldown)
# 3) 充电站停车逻辑

from controller import Supervisor
import math

TIME_STEP = 64  # 要和 world 里的 basicTimeStep 一致

# ======= 场景设置 =======
START_X = -3.0
START_Y = -3.0

GOAL_POSITION = (1.0, 1.0)
CHARGING_STATION = (3.0, -3.0)

GOAL_REACHED_DIST = 0.15   # 认为到目标 15cm 内就算到达
CHARGING_REACHED_DIST = 0.15  # 充电站范围


class RobotState:
    def __init__(self):
        self.x = START_X
        self.y = START_Y
        self.theta = 0.0

        # 电量
        self.battery_level = 100.0

        # 目标与导航相关
        self.going_to_charging = False
        self.distance_to_goal = 0.0
        self.heading_error = 0.0

        # 障碍相关
        self.obstacle_danger = 0.0
        self.left_obstacle = 0.0
        self.right_obstacle = 0.0

        # 行为选择相关
        self.active_behavior = "GOAL"   # "GOAL" / "AVOID" / "CHARGE"
        self.last_behavior = "GOAL"
        self.last_switch_tick = 0

        self.mission_done = False


class IntelligentRobotController(Supervisor):
    def __init__(self):
        super().__init__()

        self.robot_node = self.getSelf()

        # 电机
        self.left_motor = self.getDevice("left wheel motor")
        self.right_motor = self.getDevice("right wheel motor")

        self.left_motor.setPosition(float('inf'))
        self.right_motor.setPosition(float('inf'))
        self.left_motor.setVelocity(0.0)
        self.right_motor.setVelocity(0.0)

        # 距离传感器
        sensor_names = ["ps0", "ps1", "ps2", "ps3", "ps4", "ps5", "ps6", "ps7"]
        self.distance_sensors = []
        for name in sensor_names:
            s = self.getDevice(name)
            if s is not None:
                s.enable(TIME_STEP)
                self.distance_sensors.append(s)

        self.state = RobotState()
        self.tick = 0

        # 行为选择参数
        self.behavior_cooldown = 20    # 至少 20 tick 内不切换行为
        self.hysteresis_margin = 0.1   # 当前行为激活度只要不比最大低超过 0.1，就保持

    # ========== 姿态更新 ==========
    def update_pose(self):
        trans = self.robot_node.getField("translation").getSFVec3f()
        rot = self.robot_node.getField("rotation").getSFRotation()

        # 在你这个 world 里平面是 x-y，z 基本是高度
        self.state.x = trans[0]
        self.state.y = trans[1]

        axis_x, axis_y, axis_z, angle = rot
        # 假设旋转轴基本是 z 轴，angle 为朝向
        self.state.theta = angle

        # 根据当前行为决定目标点 (GOAL or CHARGE)
        if self.state.active_behavior == "CHARGE":
            gx, gy = CHARGING_STATION
            target_name = "CHARGE"
        else:
            gx, gy = GOAL_POSITION
            target_name = "GOAL"

        dx = gx - self.state.x
        dy = gy - self.state.y
        dist = math.hypot(dx, dy)
        self.state.distance_to_goal = dist

        target_theta = math.atan2(dy, dx)
        heading_err = target_theta - self.state.theta
        heading_err = (heading_err + math.pi) % (2.0 * math.pi) - math.pi
        self.state.heading_error = heading_err

        # 最终目标达成（只在目标行为是 GOAL 时判定）
        if (self.state.active_behavior != "CHARGE") and dist < GOAL_REACHED_DIST:
            if not self.state.mission_done:
                print(">>> [TASK] Final goal reached, mission done.")
            self.state.mission_done = True

        return target_name

    # ========== 传感器 ==========
    def update_sensors(self):
        if not self.distance_sensors:
            return

        values = [s.getValue() for s in self.distance_sensors]
        max_val = max(values)

        # 数值大概在 60~80 左右，越大越近（你可以之后根据实际打印调整 baseline/max_range）
        baseline = 60.0
        max_range = 80.0
        danger_raw = (max_val - baseline) / max_range
        danger = max(0.0, min(1.0, danger_raw))
        self.state.obstacle_danger = danger

        # 左/右 4 个传感器求和（假设 ps0-3 左，4-7 右）
        if len(values) == 8:
            left_sum = sum(values[0:4])
            right_sum = sum(values[4:8])
        else:
            mid = len(values) // 2
            left_sum = sum(values[:mid])
            right_sum = sum(values[mid:])

        norm = 400.0
        self.state.left_obstacle = min(1.0, left_sum / norm)
        self.state.right_obstacle = min(1.0, right_sum / norm)

    # ========== 电量更新（不再直接切换目标，只负责数值变化） ==========
    def update_battery(self, moving: bool):
        if self.state.mission_done:
            return

        # 简单电量模型
        if moving:
            self.state.battery_level -= 0.03
        else:
            self.state.battery_level -= 0.005

        if self.state.battery_level < 0.0:
            self.state.battery_level = 0.0
        if self.state.battery_level > 100.0:
            self.state.battery_level = 100.0

        # 如果在充电站范围内，并且行为是 CHARGE，则充电 + 停车
        if self.state.active_behavior == "CHARGE":
            dist_to_charge = math.hypot(
                self.state.x - CHARGING_STATION[0],
                self.state.y - CHARGING_STATION[1]
            )
            if dist_to_charge < CHARGING_REACHED_DIST:
                # 停车充电：充电由 run_loop 里给速度 0 来保证
                self.state.battery_level += 0.5
                if self.state.battery_level >= 100.0:
                    self.state.battery_level = 100.0
                    # 电量满了，下次行为选择时有机会切回 GOAL
                    # 这里不强制马上切换，由模糊行为选择控制
                    print(">>> [BAT] Fully charged at station.")

    # ========== 模糊 membership 函数 ==========
    def fuzzy_low_battery(self, batt: float) -> float:
        """
        电量模糊集合：low
        >= 60 -> 0, <= 20 -> 1 之间线性
        """
        if batt >= 60.0:
            return 0.0
        if batt <= 20.0:
            return 1.0
        # 20~60 线性插值
        return (60.0 - batt) / 40.0

    def fuzzy_obstacle_near(self, danger: float) -> float:
        """
        障碍接近程度：直接用 danger 略微强化
        """
        return max(0.0, min(1.0, danger))

    def fuzzy_far_from_goal(self, dist: float) -> float:
        """
        距离目标越远，激活越高，上限 1.0
        假设 0~1m 归一
        """
        if dist <= 0.1:
            return 0.0
        if dist >= 1.0:
            return 1.0
        return (dist - 0.1) / 0.9

    # ========== 行为选择（类似简化行为树 + 模糊激活 + 抖动抑制） ==========
    def select_behavior(self):
        batt = self.state.battery_level
        danger = self.state.obstacle_danger
        dist = self.state.distance_to_goal

        mu_low_batt = self.fuzzy_low_battery(batt)
        mu_obs = self.fuzzy_obstacle_near(danger)
        mu_far = self.fuzzy_far_from_goal(dist)

        # 基本激活度设计（你后面可以改成更复杂的模糊规则）
        act_charge = mu_low_batt               # 电量越低，越想 CHARGE
        act_avoid = mu_obs                     # 障碍越近，越想 AVOID
        act_goal = (1.0 - mu_low_batt) * max(0.0, 1.0 - mu_obs) * mu_far

        activations = {
            "CHARGE": act_charge,
            "AVOID": act_avoid,
            "GOAL": act_goal
        }

        # 找出激活度最大的行为
        best_behavior = max(activations, key=activations.get)
        best_act = activations[best_behavior]

        current = self.state.active_behavior
        current_act = activations[current]

        # 抖动抑制 1：冷却时间，在冷却期内尽量不切行为
        if (self.tick - self.state.last_switch_tick) < self.behavior_cooldown:
            # 冷却期内，只在“当前行为激活度远小于最大”时才允许切换
            if best_act > current_act + self.hysteresis_margin:
                self.state.last_behavior = current
                self.state.active_behavior = best_behavior
                self.state.last_switch_tick = self.tick
        else:
            # 冷却期外：如果当前行为激活度只比最大低一点，就保持
            if current_act + self.hysteresis_margin < best_act:
                self.state.last_behavior = current
                self.state.active_behavior = best_behavior
                self.state.last_switch_tick = self.tick

        # active_behavior 决定是否“逻辑上前往充电站”
        self.state.going_to_charging = (self.state.active_behavior == "CHARGE")

        return activations

    # ========== 计算速度命令 ==========
    def compute_command(self):
        if self.state.mission_done or self.state.battery_level <= 0.0:
            return 0.0, 0.0

        d = self.state.distance_to_goal
        e = self.state.heading_error
        danger = self.state.obstacle_danger
        left_o = self.state.left_obstacle
        right_o = self.state.right_obstacle

        max_speed = 6.28

        behavior = self.state.active_behavior

        # 如果在充电行为且已经到达充电站范围内，则完全停车充电
        if behavior == "CHARGE":
            dist_to_charge = math.hypot(
                self.state.x - CHARGING_STATION[0],
                self.state.y - CHARGING_STATION[1]
            )
            if dist_to_charge < CHARGING_REACHED_DIST:
                return 0.0, 0.0

        # 根据行为决定控制策略
        if behavior == "AVOID":
            # 避障行为：比原来更激进一点
            if danger > 0.6:
                # 高危：后退并强烈转向
                turn_bias = 3.0 if left_o > right_o else -3.0
                v = -2.5
                w = turn_bias
            else:
                # 中危：慢速前进 + 侧向绕障
                v = 1.5
                w = 4.0 * (right_o - left_o)
        elif behavior == "CHARGE":
            # 去充电站：类似 GOAL 导航，但线速度稍微保守点
            v = 3.0 * min(d, 1.0)
            w = 3.0 * e
        else:  # "GOAL"
            # 正常导航行为
            if danger > 0.5:
                # 即便在 GOAL 行为下，遇到比较大的危险也稍微让一下
                v = 2.0
                w = 3.0 * (right_o - left_o)
            else:
                v = 4.0 * min(d, 1.0)
                w = 3.0 * e

        v_left = v - w
        v_right = v + w

        v_left = max(-max_speed, min(max_speed, v_left))
        v_right = max(-max_speed, min(max_speed, v_right))

        return v_left, v_right

    # ========== 主循环 ==========
    def run_controller(self):
        last_log_tick = -999

        while self.step(TIME_STEP) != -1:
            self.tick += 1

            if self.state.battery_level <= 0.0:
                print(">>> [BAT] Battery empty, stop.")
                self.left_motor.setVelocity(0.0)
                self.right_motor.setVelocity(0.0)
                continue

            if self.state.mission_done:
                self.left_motor.setVelocity(0.0)
                self.right_motor.setVelocity(0.0)
                continue

            # 更新姿态、传感器
            target_name = self.update_pose()
            self.update_sensors()

            # 行为选择（模糊 + 抖动抑制）
            acts = self.select_behavior()

            # 根据行为计算左右轮速度
            v_left, v_right = self.compute_command()

            moving = (abs(v_left) > 0.05 or abs(v_right) > 0.05)

            # 更新电量（含充电逻辑）
            self.update_battery(moving)

            # 发送控制
            self.left_motor.setVelocity(v_left)
            self.right_motor.setVelocity(v_right)

            # 日志（减少刷屏）
            if self.tick - last_log_tick >= 10:
                last_log_tick = self.tick
                print(
                    f"[t={self.tick}] pos=({self.state.x:.2f},{self.state.y:.2f}) "
                    f"theta={self.state.theta:.2f} "
                    f"target={target_name} dist={self.state.distance_to_goal:.2f} "
                    f"batt={self.state.battery_level:.1f} "
                    f"danger={self.state.obstacle_danger:.2f} "
                    f"Lobs={self.state.left_obstacle:.2f} "
                    f"Robs={self.state.right_obstacle:.2f} "
                    f"behavior={self.state.active_behavior} "
                    f"acts={acts} "
                    f"cmd=({v_left:.2f},{v_right:.2f})"
                )


if __name__ == "__main__":
    controller = IntelligentRobotController()
    controller.run_controller()
-------------------------------------------------------33333333333格栅代码-------------------
# intelligent_robot_controller.py
# 版本：模糊行为选择 + 抖动抑制 + A* + 改进避障 & 低电优先充电

from controller import Supervisor
import math
import heapq

TIME_STEP = 64

START_X = -3.0
START_Y = -3.0

GOAL_POSITION = (1.0, 1.0)
CHARGING_STATION = (3.0, -3.0)

GOAL_REACHED_DIST = 0.15
WAYPOINT_REACHED_DIST = 0.12
CHARGING_REACHED_DIST = 0.15

MAP_MIN_X = -4.0
MAP_MAX_X = 4.0
MAP_MIN_Y = -4.0
MAP_MAX_Y = 4.0
GRID_RES = 0.1

GRID_WIDTH = int(round((MAP_MAX_X - MAP_MIN_X) / GRID_RES)) + 1
GRID_HEIGHT = int(round((MAP_MAX_Y - MAP_MIN_Y) / GRID_RES)) + 1


class RobotState:
    def __init__(self):
        self.x = START_X
        self.y = START_Y
        self.theta = 0.0

        self.battery_level = 100.0

        self.distance_to_goal = 0.0
        self.heading_error = 0.0

        self.obstacle_danger = 0.0
        self.left_obstacle = 0.0
        self.right_obstacle = 0.0

        self.active_behavior = "GOAL"   # "GOAL" / "AVOID" / "CHARGE"
        self.last_behavior = "GOAL"
        self.last_switch_tick = 0

        self.path = []
        self.path_index = 0
        self.current_high_level_target = "GOAL"

        # 卡死检测（可扩展用）
        self.last_target_dist = None
        self.no_progress_ticks = 0

        self.mission_done = False


class IntelligentRobotController(Supervisor):
    def __init__(self):
        super().__init__()

        self.robot_node = self.getSelf()

        self.left_motor = self.getDevice("left wheel motor")
        self.right_motor = self.getDevice("right wheel motor")

        self.left_motor.setPosition(float('inf'))
        self.right_motor.setPosition(float('inf'))
        self.left_motor.setVelocity(0.0)
        self.right_motor.setVelocity(0.0)

        sensor_names = ["ps0", "ps1", "ps2", "ps3", "ps4", "ps5", "ps6", "ps7"]
        self.distance_sensors = []
        for name in sensor_names:
            s = self.getDevice(name)
            if s is not None:
                s.enable(TIME_STEP)
                self.distance_sensors.append(s)

        self.state = RobotState()
        self.tick = 0

        self.behavior_cooldown = 20
        self.hysteresis_margin = 0.1

        self.occupancy = self.build_static_occupancy()
        self.plan_path_to_high_level_target("GOAL")

    # ===== 栅格转换 =====
    def world_to_grid(self, x: float, y: float):
        gx = int(round((x - MAP_MIN_X) / GRID_RES))
        gy = int(round((y - MAP_MIN_Y) / GRID_RES))
        gx = max(0, min(GRID_WIDTH - 1, gx))
        gy = max(0, min(GRID_HEIGHT - 1, gy))
        return gx, gy

    def grid_to_world(self, gx: int, gy: int):
        x = MAP_MIN_X + gx * GRID_RES
        y = MAP_MIN_Y + gy * GRID_RES
        return x, y

    def build_static_occupancy(self):
        occ = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
    
        # 统一的安全余量（可以根据效果调大/调小）
        # margin = 0.05  # 上面是计算用的，这里直接写死数值了
    
        # 每一条注释对应你发的一行：  x y z // size // rotation
    
        # 1) -0.494828 1.10576 0 // 0.2 1 2.4 // 0 0 1 -2.879...
        #   → 大概在上方的一块竖着的墙
        self.mark_obstacle_rect(
            occ,
            -0.644828, -0.344828,   # xmin, xmax
            0.55576, 1.65576        # ymin, ymax
        )
    
        # 2) 0.972293 -0.282034 0 // 0.2 1 2.4 // 0 0 1 -2.356...
        self.mark_obstacle_rect(
            occ,
            0.822293, 1.122293,
            -0.832034, 0.267966
        )
    
        # 3) -0.111627 0.292814 0 // 0.2 1 2.4 // 0 0 1 -1.5707...
        self.mark_obstacle_rect(
            occ,
            -0.261627, 0.038373,
            -0.257186, 0.842814
        )
    
        # 4) -0.509825 1.16688 0 // 0.2 1 2.4 // 0 0 1 -2.0943...
        self.mark_obstacle_rect(
            occ,
            -0.659825, -0.359825,
            0.61688, 1.71688
        )
    
        # 5) -2.7444 -2.33934 -5.3e-15 // 0.2 1 2.4 // 0 0 -1 1.309
        self.mark_obstacle_rect(
            occ,
            -2.8944, -2.5944,
            -2.88934, -1.78934
        )
    
        # 6) 0.909048 1.38008 -0.207658 // 0.2 1 2.4 // ... 1.54404
        self.mark_obstacle_rect(
            occ,
            0.759048, 1.059048,
            0.83008, 1.93008
        )
    
        # 7) 0.266012 -1.25274 -0.207658 // 0.2 1 2.4 // ... -2.84768
        self.mark_obstacle_rect(
            occ,
            0.116012, 0.416012,
            -1.80274, -0.70274
        )
    
        # 8) 1.93989 -2.64774 -0.207658 // 0.2 1 2.4 // ... -2.84768
        self.mark_obstacle_rect(
            occ,
            1.78989, 2.08989,
            -3.19774, -2.09774
        )
    
        # 9) -1.78915 -1.09284 0.02 // 0.2 1 2.4 // 0 0 -1 1.309
        self.mark_obstacle_rect(
            occ,
            -1.93915, -1.63915,
            -1.64284, -0.54284
        )
    
        # 10) -0.861625 -2.03397 -0.08 // 0.2 1 2.4 // 0 0 1 -2.356...
        self.mark_obstacle_rect(
            occ,
            -1.011625, -0.711625,
            -2.58397, -1.48397
        )
    
        # 11) -3.21813 0.234459 -0.16 // 0.2 1 2.4 // 0 0 1 -1.0471...
        self.mark_obstacle_rect(
            occ,
            -3.36813, -3.06813,
            -0.315541, 0.784459
        )
        # --- New obstacle A ---
        # -0.124335 -0.855721 -0.1305 // 0.2 1 2.4 // rotation...
        self.mark_obstacle_rect(
            occ,
            -0.274335, 0.025665,     # xmin, xmax
            -1.405721, -0.305721     # ymin, ymax
        )
    
        # --- New obstacle B ---
        # -1.87502 -2.30412 -0.1305 // 0.2 1 2.4 // rotation...
        self.mark_obstacle_rect(
            occ,
            -2.02502, -1.72502,      # xmin, xmax
            -2.85412, -1.75412       # ymin, ymax
        )
        
    
        return occ

    def mark_obstacle_rect(self, occ, xmin, xmax, ymin, ymax):
        gx_min, gy_min = self.world_to_grid(xmin, ymin)
        gx_max, gy_max = self.world_to_grid(xmax, ymax)
        for gy in range(min(gy_min, gy_max), max(gy_min, gy_max) + 1):
            for gx in range(min(gx_min, gx_max), max(gx_min, gx_max) + 1):
                occ[gy][gx] = 1

    # ===== A* =====
    def astar(self, start_xy, goal_xy):
        sx, sy = start_xy
        gx, gy = goal_xy

        start_gx, start_gy = self.world_to_grid(sx, sy)
        goal_gx, goal_gy = self.world_to_grid(gx, gy)

        if self.occupancy[goal_gy][goal_gx] == 1:
            print(">>> [A*] Goal grid occupied, path may fail.")

        open_set = []
        heapq.heappush(open_set, (0.0, (start_gx, start_gy)))
        came_from = {}
        g_score = {(start_gx, start_gy): 0.0}

        def heuristic(ax, ay, bx, by):
            return abs(ax - bx) + abs(ay - by)

        closed = set()
        max_iter = GRID_WIDTH * GRID_HEIGHT * 4

        while open_set and max_iter > 0:
            max_iter -= 1
            _, (cx, cy) = heapq.heappop(open_set)
            if (cx, cy) in closed:
                continue
            closed.add((cx, cy))

            if cx == goal_gx and cy == goal_gy:
                path = []
                cur = (cx, cy)
                while cur in came_from:
                    path.append(cur)
                    cur = came_from[cur]
                path.append((start_gx, start_gy))
                path.reverse()
                wp = [self.grid_to_world(px, py) for (px, py) in path]
                return wp

            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    nx = cx + dx
                    ny = cy + dy
                    if not (0 <= nx < GRID_WIDTH and 0 <= ny < GRID_HEIGHT):
                        continue
                    if self.occupancy[ny][nx] == 1:
                        continue

                    tentative_g = g_score[(cx, cy)] + math.hypot(dx, dy)
                    if (nx, ny) not in g_score or tentative_g < g_score[(nx, ny)]:
                        g_score[(nx, ny)] = tentative_g
                        f = tentative_g + heuristic(nx, ny, goal_gx, goal_gy)
                        heapq.heappush(open_set, (f, (nx, ny)))
                        came_from[(nx, ny)] = (cx, cy)

        print(">>> [A*] Failed to find path.")
        return []

    def plan_path_to_high_level_target(self, target_type: str):
        if target_type == "CHARGE":
            target_xy = CHARGING_STATION
        else:
            target_xy = GOAL_POSITION

        start_xy = (self.state.x, self.state.y)
        path = self.astar(start_xy, target_xy)

        if not path:
            print(f">>> [A*] No path found to {target_type}, use direct point.")
            self.state.path = [target_xy]
            self.state.path_index = 0
        else:
            self.state.path = path
            self.state.path_index = 0
            print(f">>> [A*] Path to {target_type} planned with {len(path)} waypoints.")

        self.state.current_high_level_target = target_type
        self.state.last_target_dist = None
        self.state.no_progress_ticks = 0

    def get_current_path_target_point(self):
        if self.state.current_high_level_target == "CHARGE":
            fallback = CHARGING_STATION
        else:
            fallback = GOAL_POSITION

        if not self.state.path:
            return fallback
        if self.state.path_index >= len(self.state.path):
            return fallback
        return self.state.path[self.state.path_index]

    # ===== 姿态更新 =====
    def update_pose(self):
        trans = self.robot_node.getField("translation").getSFVec3f()
        rot = self.robot_node.getField("rotation").getSFRotation()

        self.state.x = trans[0]
        self.state.y = trans[1]

        axis_x, axis_y, axis_z, angle = rot
        self.state.theta = angle

        tx, ty = self.get_current_path_target_point()
        dx = tx - self.state.x
        dy = ty - self.state.y
        dist = math.hypot(dx, dy)
        self.state.distance_to_goal = dist

        target_theta = math.atan2(dy, dx)
        heading_err = target_theta - self.state.theta
        heading_err = (heading_err + math.pi) % (2.0 * math.pi) - math.pi
        self.state.heading_error = heading_err

        gx, gy = GOAL_POSITION
        dist_final_goal = math.hypot(self.state.x - gx, self.state.y - gy)
        if self.state.current_high_level_target != "CHARGE" and dist_final_goal < GOAL_REACHED_DIST:
            if not self.state.mission_done:
                print(">>> [TASK] Final goal reached, mission done.")
            self.state.mission_done = True

        # 路径点更新
        if dist < WAYPOINT_REACHED_DIST and self.state.path:
            if self.state.path_index < len(self.state.path) - 1:
                self.state.path_index += 1

        # 记录到高层目标的距离，用于卡死检测（可扩展用）
        if self.state.current_high_level_target == "CHARGE":
            tx2, ty2 = CHARGING_STATION
        else:
            tx2, ty2 = GOAL_POSITION
        dist_to_high_target = math.hypot(self.state.x - tx2, self.state.y - ty2)
        if self.state.last_target_dist is None:
            self.state.last_target_dist = dist_to_high_target
        else:
            if abs(dist_to_high_target - self.state.last_target_dist) < 0.005:
                self.state.no_progress_ticks += 1
            else:
                self.state.no_progress_ticks = 0
            self.state.last_target_dist = dist_to_high_target

        return self.state.current_high_level_target

    # ===== 传感器 =====
    def update_sensors(self):
        if not self.distance_sensors:
            return

        values = [s.getValue() for s in self.distance_sensors]
        max_val = max(values)

        baseline = 60.0
        max_range = 80.0
        danger_raw = (max_val - baseline) / max_range
        danger = max(0.0, min(1.0, danger_raw))
        self.state.obstacle_danger = danger

        if len(values) == 8:
            left_sum = sum(values[0:4])
            right_sum = sum(values[4:8])
        else:
            mid = len(values) // 2
            left_sum = sum(values[:mid])
            right_sum = sum(values[mid:])

        norm = 400.0
        self.state.left_obstacle = min(1.0, left_sum / norm)
        self.state.right_obstacle = min(1.0, right_sum / norm)

    # ===== 电量 =====
    def update_battery(self, moving: bool):
        if self.state.mission_done:
            return

        if moving:
            self.state.battery_level -= 0.02
        else:
            self.state.battery_level -= 0.005

        if self.state.battery_level < 0.0:
            self.state.battery_level = 0.0
        if self.state.battery_level > 100.0:
            self.state.battery_level = 100.0

        if self.state.active_behavior == "CHARGE":
            dist_to_charge = math.hypot(
                self.state.x - CHARGING_STATION[0],
                self.state.y - CHARGING_STATION[1]
            )
            if dist_to_charge < CHARGING_REACHED_DIST:
                self.state.battery_level += 0.5
                if self.state.battery_level >= 100.0:
                    self.state.battery_level = 100.0
                    print(">>> [BAT] Fully charged at station.")

    # ===== 模糊 membership =====
    def fuzzy_low_battery(self, batt: float) -> float:
        if batt >= 60.0:
            return 0.0
        if batt <= 20.0:
            return 1.0
        return (60.0 - batt) / 40.0

    def fuzzy_obstacle_near(self, danger: float) -> float:
        return max(0.0, min(1.0, danger))

    def fuzzy_far_from_goal(self, dist: float) -> float:
        if dist <= 0.1:
            return 0.0
        if dist >= 1.0:
            return 1.0
        return (dist - 0.1) / 0.9

    # ===== 行为选择（改：低电优先 CHARGE） =====
    def select_behavior(self):
        batt = self.state.battery_level
        danger = self.state.obstacle_danger
        dist = self.state.distance_to_goal

        mu_low_batt = self.fuzzy_low_battery(batt)
        mu_obs = self.fuzzy_obstacle_near(danger)
        mu_far = self.fuzzy_far_from_goal(dist)

        act_charge = mu_low_batt
        act_avoid = mu_obs
        act_goal = (1.0 - mu_low_batt) * max(0.0, 1.0 - mu_obs) * mu_far

        activations = {
            "CHARGE": act_charge,
            "AVOID": act_avoid,
            "GOAL": act_goal
        }

        # 低电优先级：当电量 < 25% 或 低电模糊度 > 0.8 时，强制 CHARGE
        if batt < 25.0 or mu_low_batt > 0.8:
            if self.state.current_high_level_target != "CHARGE":
                self.plan_path_to_high_level_target("CHARGE")
            self.state.active_behavior = "CHARGE"
            return activations

        best_behavior = max(activations, key=activations.get)
        best_act = activations[best_behavior]

        current = self.state.active_behavior
        current_act = activations[current]
        switched = False

        if (self.tick - self.state.last_switch_tick) < self.behavior_cooldown:
            if best_act > current_act + self.hysteresis_margin:
                self.state.last_behavior = current
                self.state.active_behavior = best_behavior
                self.state.last_switch_tick = self.tick
                switched = True
        else:
            if current_act + self.hysteresis_margin < best_act:
                self.state.last_behavior = current
                self.state.active_behavior = best_behavior
                self.state.last_switch_tick = self.tick
                switched = True

        if switched:
            if self.state.active_behavior == "CHARGE" and self.state.current_high_level_target != "CHARGE":
                self.plan_path_to_high_level_target("CHARGE")
            elif self.state.active_behavior == "GOAL" and self.state.current_high_level_target != "GOAL":
                self.plan_path_to_high_level_target("GOAL")

        return activations

    # ===== 控制命令（改：高危险双侧障碍时直线后退） =====
    def compute_command(self):
        if self.state.mission_done or self.state.battery_level <= 0.0:
            return 0.0, 0.0

        d = self.state.distance_to_goal
        e = self.state.heading_error
        danger = self.state.obstacle_danger
        left_o = self.state.left_obstacle
        right_o = self.state.right_obstacle

        max_speed = 6.28
        behavior = self.state.active_behavior

        if behavior == "CHARGE":
            dist_to_charge = math.hypot(
                self.state.x - CHARGING_STATION[0],
                self.state.y - CHARGING_STATION[1]
            )
            if dist_to_charge < CHARGING_REACHED_DIST:
                return 0.0, 0.0

        # 高危险 + 左右都很近：判定为“贴墙/夹缝”，先直线后退
        if danger > 0.9 and left_o > 0.9 and right_o > 0.9:
            v = -2.0
            w = 0.0
        else:
            if behavior == "AVOID":
                if danger > 0.6:
                    turn_bias = 3.0 if left_o > right_o else -3.0
                    v = -2.0   # 稍微小一点，避免过分 spin
                    w = turn_bias
                else:
                    v = 1.5
                    w = 4.0 * (right_o - left_o)
            elif behavior == "CHARGE":
                v = 3.0 * min(d, 1.0)
                w = 3.0 * e
            else:  # GOAL
                if danger > 0.5:
                    v = 2.0
                    w = 3.0 * (right_o - left_o)
                else:
                    v = 4.0 * min(d, 1.0)
                    w = 3.0 * e

        v_left = v - w
        v_right = v + w

        v_left = max(-max_speed, min(max_speed, v_left))
        v_right = max(-max_speed, min(max_speed, v_right))

        return v_left, v_right

    # ===== 主循环 =====
    def run_controller(self):
        last_log_tick = -999

        while self.step(TIME_STEP) != -1:
            self.tick += 1

            if self.state.battery_level <= 0.0:
                print(">>> [BAT] Battery empty, stop.")
                self.left_motor.setVelocity(0.0)
                self.right_motor.setVelocity(0.0)
                continue

            if self.state.mission_done:
                self.left_motor.setVelocity(0.0)
                self.right_motor.setVelocity(0.0)
                continue

            target_name = self.update_pose()
            self.update_sensors()

            acts = self.select_behavior()

            v_left, v_right = self.compute_command()
            moving = (abs(v_left) > 0.05 or abs(v_right) > 0.05)

            self.update_battery(moving)

            self.left_motor.setVelocity(v_left)
            self.right_motor.setVelocity(v_right)

            if self.tick - last_log_tick >= 20:
                last_log_tick = self.tick
                print(
                    f"[t={self.tick}] pos=({self.state.x:.2f},{self.state.y:.2f}) "
                    f"theta={self.state.theta:.2f} "
                    f"HL_target={self.state.current_high_level_target} "
                    f"dist={self.state.distance_to_goal:.2f} "
                    f"batt={self.state.battery_level:.1f} "
                    f"danger={self.state.obstacle_danger:.2f} "
                    f"Lobs={self.state.left_obstacle:.2f} "
                    f"Robs={self.state.right_obstacle:.2f} "
                    f"behavior={self.state.active_behavior} "
                    f"acts={acts} "
                    f"wp_idx={self.state.path_index}/{len(self.state.path)} "
                    f"cmd=({v_left:.2f},{v_right:.2f})"
                )


if __name__ == "__main__":
    controller = IntelligentRobotController()
    controller.run_controller()
